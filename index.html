<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vortex Bypasser</title>

  <!-- Optional: build-time injection fallback -->
  <!-- <meta name="vortex-api-key" content="%VORTEX_API_KEY%"> -->

  <link rel="stylesheet" href="styles.css" />
  <script src="https://www.google.com/recaptcha/api.js" async defer></script>
</head>
<body>
  <h1>üå™Ô∏è Vortex Bypasser</h1>

  <div class="container">
    <input id="urlInput" type="text" placeholder="Enter URL..." />

    <!-- small bypass button (type=button prevents accidental form submit) -->
    <button id="bypassBtn" type="button">Bypass</button>

    <div class="toggle-container">
      <label class="switch">
        <input type="checkbox" id="autoRedirect" />
        <span class="slider"></span>
      </label>
      <p class="toggle-label">Auto Redirect</p>
    </div>

    <div class="result-box" id="resultBox">
      <div id="resultText">Result will appear here...</div>
      <div id="timer" class="timer">00:00.000</div>
    </div>

    <div class="supported-box">
      <h3>Supported Links</h3>
      <ul>
        <li>https://work.ink</li>
        <li>https://linkvertise</li>
        <li>https://link-unlocker.com</li>
        <li>https://pandadevelopment.net</li>
        <li>https://keyrblx.com</li>
        <li>https://krnl.cat</li>
      </ul>
    </div>

    <div class="buttons">
      <a href="https://discord.gg/PCQvUSUEsE" target="_blank" class="btn">Join Discord</a>
      <a href="https://discord.com/oauth2/authorize?client_id=1355400268103290910" target="_blank" class="btn">Invite Bot</a>
    </div>

    <p class="footer">Powered by Trw.lat</p>
  </div>

  <script>
    // --- Elements ---
    const resultBox = document.getElementById("resultBox");
    const resultText = document.getElementById("resultText");
    const bypassBtn = document.getElementById("bypassBtn");
    const autoRedirectToggle = document.getElementById("autoRedirect");
    const timerEl = document.getElementById("timer");
    const urlInput = document.getElementById("urlInput");

    // --- Supported API hosts ---
    const generalAPIs = ["work.ink", "linkvertise", "link-unlocker.com"];
    const v2APIs = ["pandadevelopment.net", "keyrblx.com", "krnl.cat"];

    // --- Timer utilities ---
    let timerInterval = null;
    let startTime = null;
    function startTimer() {
      stopTimer(); // ensure clean
      startTime = performance.now();
      timerEl.textContent = formatElapsed(0);
      timerInterval = setInterval(() => {
        const elapsed = performance.now() - startTime;
        timerEl.textContent = formatElapsed(elapsed);
      }, 16); // ~60fps for smoothness
    }
    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      startTime = null;
    }
    function formatElapsed(ms) {
      const totalMs = Math.max(0, ms | 0);
      const minutes = Math.floor(totalMs / 60000);
      const seconds = Math.floor((totalMs % 60000) / 1000);
      const millis = totalMs % 1000;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2,"0")}.${String(millis).padStart(3,"0")}`;
    }

    // --- UI helpers ---
    function setStatus(text) {
      resultText.textContent = text;
    }
    function setError(text) {
      resultText.textContent = "Error: " + text;
    }
    function setProcessing(isProcessing) {
      bypassBtn.disabled = isProcessing;
      bypassBtn.style.opacity = isProcessing ? "0.85" : "1";
      if (isProcessing) bypassBtn.textContent = "Processing...";
      else bypassBtn.textContent = "Bypass";
    }

    // --- Get API key (tries /api/key then meta fallback) ---
    async function getApiKey() {
      // Try serverless endpoint first
      try {
        const res = await fetch('/api/key', { cache: 'no-store' });
        if (res.ok) {
          const j = await res.json();
          if (j && j.key) return j.key;
        }
      } catch (e) {
        // ignore, fallback next
        console.warn('Failed to fetch /api/key:', e);
      }

      // Fallback to meta tag (build-time injection)
      const meta = document.querySelector('meta[name="vortex-api-key"]');
      if (meta && meta.content) return meta.content;

      throw new Error("API key not configured. Set VORTEX_API_KEY in Vercel and expose via /api/key or build-time meta tag.");
    }

    // --- Poll thread helper with max attempts + 0.5s delay ---
    async function pollThread(threadId, apiKey) {
      const pollUrl = `https://trw.lat/api/v2/threadcheck?id=${encodeURIComponent(threadId)}`;
      let attempts = 0;
      const maxAttempts = 120; // as requested
      const delayMs = 500;
      while (attempts < maxAttempts) {
        attempts++;
        try {
          const r = await fetch(pollUrl, { headers: { "x-api-key": apiKey } });
          if (!r.ok) {
            // continue polling on non-2xx? decide to treat as transient (you can adjust)
            console.warn('Polling returned non-OK:', r.status);
          } else {
            const data = await r.json();
            if (data.status === "Done" && data.result) {
              return { ok: true, result: data.result };
            }
            // If thread returns an error field, return it
            if (data.status === "Error" || data.error) {
              return { ok: false, error: data.error || 'Thread returned error' };
            }
          }
        } catch (err) {
          // network or JSON parse errors - bubble out as polling error
          return { ok: false, error: err.message || String(err) };
        }
        // wait
        await new Promise(r => setTimeout(r, delayMs));
      }
      return { ok: false, error: 'Timed out waiting for thread result' };
    }

    // --- Main bypass flow ---
    async function handleBypass() {
      setProcessing(true);
      setStatus("Validating input...");
      timerEl.textContent = "00:00.000";

      const url = urlInput.value.trim();
      if (!url) {
        setError("Please enter a URL.");
        setProcessing(false);
        return;
      }

      let apiUrl = "";
      let useV2 = false;
      if (generalAPIs.some(d => url.includes(d))) {
        apiUrl = `https://trw.lat/api/bypass?url=${encodeURIComponent(url)}`;
      } else if (v2APIs.some(d => url.includes(d))) {
        apiUrl = `https://trw.lat/api/v2/bypass?url=${encodeURIComponent(url)}`;
        useV2 = true;
      } else {
        setError("Unsupported URL.");
        setProcessing(false);
        return;
      }

      startTimer();

      let API_KEY;
      try {
        API_KEY = await getApiKey();
      } catch (err) {
        stopTimer();
        setError(err.message || String(err));
        setProcessing(false);
        return;
      }

      setStatus("Sending request...");
      try {
        const res = await fetch(apiUrl, { headers: { "x-api-key": API_KEY } });
        if (!res.ok) {
          const txt = await res.text().catch(()=>null);
          stopTimer();
          setError(`Remote API returned ${res.status}${txt ? `: ${txt}` : ''}`);
          setProcessing(false);
          return;
        }
        const data = await res.json();

        // v2 thread flow
        if (useV2 && data.ThreadID) {
          setStatus("Task started ‚Äî polling for completion...");
          const polled = await pollThread(data.ThreadID, API_KEY);
          if (polled.ok) {
            stopTimer();
            setStatus(polled.result);
            if (autoRedirectToggle.checked) {
              // small delay so user sees the result and timer stop
              setTimeout(()=> window.location.href = polled.result, 200);
            }
          } else {
            stopTimer();
            setError(polled.error || 'Polling failed');
          }
        } else if (data.result) {
          stopTimer();
          setStatus(data.result);
          if (autoRedirectToggle.checked) {
            setTimeout(()=> window.location.href = data.result, 200);
          }
        } else {
          stopTimer();
          setError("Unexpected response from API.");
        }
      } catch (err) {
        stopTimer();
        setError(err.message || String(err));
      } finally {
        setProcessing(false);
      }
    }

    // Add click and Enter handlers
    bypassBtn.addEventListener("click", handleBypass);
    urlInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleBypass();
      }
    });

    // --- Helpful: expose debug function to console for quick testing ---
    window._vb_test = {
      startTimer, stopTimer, formatElapsed
    };
  </script>

  <!-- Vercel Analytics + Speed Insights (defer for performance) -->
  <!-- Ensure you enabled Analytics & Speed Insights in the Vercel dashboard -->
  <script defer src="https://cdn.vercel-insights.com/v1/script.analytics.js"></script>
  <script defer src="https://cdn.vercel-insights.com/v1/script.debug.js"></script>
</body>
</html>
